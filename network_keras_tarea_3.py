# -*- coding: utf-8 -*-
"""Network Keras Tarea 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HflJyu4iai5k8jy2qlkDpscnnFNCSR6R
"""

#importamos las liberiaras que usaremos de tensorflow
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
#la funcion de activacion sigue siendo la sigmoide
from tensorflow.keras.layers import Dense, Activation
from tensorflow.keras.optimizers import SGD #importamos el SGD
#importamos mnist ahora sin necesidad de descargarla en la computadora
from tensorflow.keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt #esta para poder graficar

#Definimos los paramentros a usar mismos de la network de la tarea 3
learning_rate = 0.001
momentum = 0.9
epochs = 30
batch_size = 10
num_classes = 10

# Cargamos los datos de Mnist tanto de entrenamiento como de prueba
(x_train, y_train), (x_test, y_test) = mnist.load_data()
#convertimos las imagenes en un vector de 784 entradas y normalizamos entre 0 y 1
x_train = x_train.reshape(-1, 784).astype("float32") / 255.0
x_test = x_test.reshape(-1, 784).astype("float32") / 255.0

# One-hot encoding para nombrar a cada digito entre 0 y 9 como un vector
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

#iniciamos con una secuancial
model = Sequential()
#la capa oculta tendra 30 neuronas usara la sigmoide en cada vector de 784 entradas
model.add(Dense(30, activation='sigmoid', input_shape=(784,)))
#saldra en una capa de 10 neuronas usando igula la sigmoide
model.add(Dense(num_classes, activation='sigmoid'))
# definimos la funcion de costo binary usamos el optimizador momento
#asi mismo las metricas de como va todo dado por accuracy
optimizer = SGD(learning_rate=learning_rate, momentum=momentum)
model.compile(loss="binary_crossentropy", optimizer=optimizer, metrics=["accuracy"])

#el entranamiento tendra enta forma
#se entrena a la red con los datos usando las epicas
#se guarda la informacion en history
history = model.fit(
    x_train, y_train,
    batch_size=batch_size,
    epochs=epochs,
    validation_data=(x_test, y_test),
    verbose=1
)

# se evalua el modelo
score = model.evaluate(x_test, y_test, verbose=1)
#imprima el costo del entrenamiento y la precicion con la que le atina
print(f"Test loss: {score[0]:.4f}")
print(f"Test accuracy: {score[1]:.4f}")

# Con esto generamos la grafica de costos vs epochs de el test y entrenamiento
plt.plot(history.history['loss'], label="Entrenamiento")
plt.plot(history.history['val_loss'], label="Validaci√≥n")
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.title("Costo vs Epochs")
plt.legend()
plt.show()